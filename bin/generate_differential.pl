#!/usr/bin/perl

# Timothy J. Parnell, PhD
# Huntsman Cancer Institute
# University of Utah
# Salt Lake City, UT 84112
#  
# This package is free software; you can redistribute it and/or modify
# it under the terms of the Artistic License 2.0.  
# 
# Updated versions of this file may be found in the repository
# https://github.com/HuntsmanCancerInstitute/MultiRepMacsChIPSeq


use strict;
use Getopt::Long;
use File::Which;
use File::Spec;
use File::Basename qw(fileparse);
use Parallel::ForkManager;
use Bio::ToolBox::big_helper qw(
	generate_chromosome_file
	wig_to_bigwig_conversion
);



# variables
my $input1;
my $input2;
my $delta;
my $length;
my $gap;
my $outdir;
my $manwig = sprintf("%s", which 'manipulate_wig.pl');
my $wig2bw = sprintf("%s", which 'wigToBigWig');
my $bw2bdg = sprintf("%s", which 'bigWigToBedGraph');
my $macs   = sprintf("%s", which 'macs2');
my $bwconvert;
my $database;
my $help;


### Documentation
my $docs = <<DOC;

A script to generate differential enrichment track files. These are 
generated from the log2FE bigWig tracks generated by the 
mulitrep_macs2_pipeline.pl script, or the logFE tracks from Macs2.
Two new tracks are generated, representing the enrichment of each 
ChIP relative to the other ChIP. Depleted regions are set to zero.

Differential tracks are generated by subtracting input2 from input1, 
equivalent to input1 over input2 in non-log space.

If new peaks are to be re-called, specify the minimum delta, peak 
length, and gap length. Otherwise, new peaks can be called manually 
using the macs2 bdgpeakcall function. 


USAGE: generate_differential.pl -1 <chip1.log2FE.bw> -2 <chip2.log2FE.bw>

OPTIONS:
  Required 
    -1 --in1 <file>         The logFE bw or bdg file for ChIP-1
    -2 --in2 <file>         The logFE bw or bdg file for ChIP-2
  
  Re-call peaks (optional)
    --delta <float>         Minimum delta score to call a peak
    --len <int>             Minimum length of peak in bp
    --gap <int>             Minimum length of gap in bp
  
  Paths
    --macs <path>           ($macs)
    --manwig <path>         ($manwig)
    --w2bw <path>           ($wig2bw)
    --bw2w <path>           ($bw2bdg)
  
  General
    --out <path>            Alternate output directory
    --bw                    Convert output differential files to bw
                               default true if input is bw
                               use --nobw for false
    --db <file>             Indexed database for converting to bw
                               default uses input bigWig
    --help                  Print documentation
DOC


unless (@ARGV) {
	print $docs;
	exit;
}


### Options
GetOptions(
	'1|in1=s'           => \$input1,
	'2|in2=s'           => \$input2,
	'delta=f'           => \$delta,
	'len=i'             => \$length,
	'gap=i'             => \$gap,
	'out=s'             => \$outdir,
	'macs=s'            => \$macs,
	'manwig=s'          => \$manwig,
	'w2bw=s'            => \$wig2bw,
	'bw2w=s'            => \$bw2bdg,
	'bw!'               => \$bwconvert,
	'db=s'              => \$database,
	'help!'             => \$help,
) or die "unrecognized option!\n";

# check options
if ($help) {
	print $docs;
	exit;
}
die "manipulate_wig.pl not in your PATH!\n" unless $manwig;
die "wigToBigWig not in your PATH!\n" unless $wig2bw;
die "bigWigToBedGraph not in your PATH!\n" unless $bw2bdg;
die "Macs2 not in your PATH!\n" unless $macs;
if (not $input1 and not $input2 and scalar(@ARGV)) {
	# user provided as list
	$input1 = shift @ARGV;
	$input2 = shift @ARGV or die "must provide two input "
}
if ($input1 eq $input2) {
	die "Silly! Both inputs are the same!\n";
}
my $callpeak = 0;
if ($delta and $length and $gap) {
	$callpeak = 1;
}


# Initialize ForkManager
my $pm = Parallel::ForkManager->new(2);


### Inputs
my ($base1, $path1, $ext1) = get_path_name($input1);
$base1 =~ s/log2?fe//;
my ($base2, $path2, $ext2) = get_path_name($input2);
$base1 =~ s/log2?fe//;

# check bigWig output
if (not defined $bwconvert) {
	if ($ext1 eq '.bw' and $ext2 eq '.bw') {
		$bwconvert = 1;
		print " will convert output files to bigWig\n";
		unless ($database) {
			# recycle bigWig file as a database
			$database = $input1;
		}
	}
}
if ($bwconvert and not $database) {
	if ($ext1 eq '.bw') {
		$database = $input1;
	}
	elsif ($ext2 eq '.bw') {
		$database = $input2;
	}
	else {
		$bwconvert = 0;
		print " no database file defined, will not convert to bigWig\n";
	}
}




### Calculate names
my ($bdg1, $bdg2, $dif1, $dif2, $enr1, $enr2, $peak1, $peak2);

if ($outdir) {
	# first make the directory
	mkdir $outdir or die "unable to make directory $outdir! $!\n";
	
	# bedgraph
	$bdg1 = File::Spec->catfile($outdir, $base1 . '.zeroed.bdg');
	$bdg2 = File::Spec->catfile($outdir, $base2 . '.zeroed.bdg');
	$bdg1 = File::Spec->catfile($outdir, $base1 . '.zeroed.bdg');
	$bdg2 = File::Spec->catfile($outdir, $base2 . '.zeroed.bdg');
	# differential
	$dif1 = File::Spec->catfile($outdir, $base1 . '.differential.bdg');
	$dif2 = File::Spec->catfile($outdir, $base2 . '.differential.bdg');
	# enrichment - extension added later
	$enr1 = File::Spec->catfile($outdir, $base1 . '.enrichment');
	$enr2 = File::Spec->catfile($outdir, $base2 . '.enrichment');
	# peak
	$peak1 = File::Spec->catfile($outdir, $base1 . '.enriched.narrowPeak');
	$peak2 = File::Spec->catfile($outdir, $base2 . '.enriched.narrowPeak');
}
else {
	# bedgraph
	$bdg1 = File::Spec->catfile($path1, $base1 . '.zeroed.bdg');
	$bdg2 = File::Spec->catfile($path2, $base2 . '.zeroed.bdg');
	# differential
	$dif1 = File::Spec->catfile($path1, $base1 . '.differential.bdg');
	$dif2 = File::Spec->catfile($path2, $base2 . '.differential.bdg');
	# enrichment - extension added later
	$enr1 = File::Spec->catfile($path1, $base1 . '.enrichment');
	$enr2 = File::Spec->catfile($path2, $base2 . '.enrichment');
	# peak
	$peak1 = File::Spec->catfile($path1, $base1 . '.enriched.narrowPeak');
	$peak2 = File::Spec->catfile($path2, $base2 . '.enriched.narrowPeak');
}


 


### Convert
print " Zero-ing depleted regions in input files\n";
foreach my $i (1..2) {
	$pm->start and next;
	if ($i == 1) {
		# first
		convert_to_minzero_bedgraph($input1, $bdg1) or 
			die "something went wrong with conversion!\n";
	}
	else {
		# second
		convert_to_minzero_bedgraph($input2, $bdg2) or 
			die "something went wrong with conversion!\n";
	}
	$pm->finish;
}
$pm->wait_all_children;




### Generate differential files
print " Generating differential files\n";
foreach my $i (1..2) {
	$pm->start and next;
	if ($i == 1) {
		# first
		generate_differential_bedgraph($bdg1, $bdg2, $dif1) or 
			die "something went wrong with conversion!\n";
	}
	else {
		# second
		generate_differential_bedgraph($bdg2, $bdg1, $dif2) or 
			die "something went wrong with conversion!\n";
	}
	$pm->finish;
}
$pm->wait_all_children;



### Convert
print " Zero-ing depleted regions in differential files\n";
foreach my $i (1..2) {
	# if we're not recalling peaks, then we can convert to bigWig here
	
	$pm->start and next;
	if ($i == 1) {
		# first 
		if (not $callpeak and $bwconvert) {
			# convert straight to bigWig here
			convert_to_minzero_bedgraph($dif1, $enr1. '.bw', $database) or 
				die "something went wrong with conversion!\n";
		}
		else {
			convert_to_minzero_bedgraph($dif1, $enr1. '.bdg') or 
				die "something went wrong with conversion!\n";
		}
	}
	else {
		# second
		if (not $callpeak and $bwconvert) {
			# convert straight to bigWig here
			convert_to_minzero_bedgraph($dif2, $enr2. '.bw', $database) or 
				die "something went wrong with conversion!\n";
		}
		else {
			convert_to_minzero_bedgraph($dif2, $enr2. '.bdg') or 
				die "something went wrong with conversion!\n";
		}
	}
	$pm->finish;
}
$pm->wait_all_children;



### Call peaks
if ($callpeak) {
	print " Calling peaks on enrichment files\n";
	
	foreach my $i (1..2) {
		$pm->start and next;
		if ($i == 1) {
			call_peaks($enr1 . '.bdg', $peak1) or 
				die "something went wrong with first peak calling!\n";
		}
		else {
			call_peaks($enr2 . '.bdg', $peak2) or 
				die "something went wrong with second peak calling!\n";
		}
		$pm->finish;
	}
	$pm->wait_all_children;

	# Convert to bigWig
	if ($bwconvert and $database) {
		foreach my $i (1..2) {
			$pm->start and next;
			if ($i == 1) {
				# first
				my $enr1bw = wig_to_bigwig_conversion(
					wig     => $enr1 . '.bdg',
					db      => $database,
					bwapppath => $wig2bw
				);
				print " wrote bigWig file $enr1bw\n";
			}
			else {
				# first
				my $enr2bw = wig_to_bigwig_conversion(
					wig     => $enr2 . '.bdg',
					db      => $database,
					bwapppath => $wig2bw
				);
				print " wrote bigWig file $enr2bw\n";
			}
			$pm->finish;
		}
		$pm->wait_all_children;
	}
}




### Cleanup
unlink($bdg1, $bdg2, $dif1, $dif2);
if ($bwconvert) {
	unlink($enr1 . '.bdg', $enr2 . '.bdg');
}




################ Subroutines


sub get_path_name {
	my $file = shift;
	my ($basename, $path, $extension) = fileparse($file, qr/\.(?:bw|bigwig|bdg|bg|bedgraph)$/);
	unless ($extension) {
		die "$file doesn't have a bedGraph or bigWig extension: bw|bigwig|bdg|bg|bedgraph\n";
	}
	return ($basename, $path, $extension);
}

sub convert_to_minzero_bedgraph {
	my ($infile, $outfile, $db) = @_;
	print " Converting $infile to $outfile...\n";
	
	# generate command
	my $command = sprintf("%s --in %s --min 0 --out %s --bw2w %s --w2bw %s", $manwig, $infile, 
		$outfile, $bw2bdg, $wig2bw);
	if ($db) {
		# add database in case this was added
		$command .= " --db $db";
	}
	my $raw = qx($command);
	if ($raw =~ m/wrote file $outfile/) {
		# completed successfully
		return 1;
	}
	else {
		return 0;
	}
}

sub generate_differential_bedgraph {
	my ($tfile, $cfile, $outfile) = @_;
	print " Generating enriched file $outfile...\n";
	
	# generate command
	my $command = sprintf("%s bdgcmp -t %s -c %s -m subtract -o %s 2>&1", $macs, $tfile, 
		$cfile, $outfile);
	my $raw = qx($command);
	if ($raw =~ m/Please check '$outfile'!/) {
		# completed successfully
		return 1;
	}
	else {
		return 0;
	}
}

sub call_peaks {
	my ($infile, $outfile) = @_;
	print " Calling peaks on $infile...\n";
	
	# generate command
	my $command = sprintf("%s bdgpeakcall -i %s -c %s -l %s -g %s -o %s 2>&1", $macs, $infile, 
		$delta, $length, $gap, $outfile);
	my $raw = qx($command);
	if ($raw =~ m/Done/) {
		# completed successfully
		return 1;
	}
	else {
		return 0;
	}
}


