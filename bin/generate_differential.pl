#!/usr/bin/perl

# Timothy J. Parnell, PhD
# Huntsman Cancer Institute
# University of Utah
# Salt Lake City, UT 84112
#  
# This package is free software; you can redistribute it and/or modify
# it under the terms of the Artistic License 2.0.  
# 
# Updated versions of this file may be found in the repository
# https://github.com/HuntsmanCancerInstitute/MultiRepMacsChIPSeq


use strict;
use Getopt::Long;
use File::Which;
use File::Spec;
use File::Path qw(make_path);
use File::Basename qw(fileparse);
use Parallel::ForkManager;
use Bio::ToolBox::big_helper qw(
	generate_chromosome_file
	wig_to_bigwig_conversion
);


my $VERSION = 2;


# variables
my $input1;
my $input2;
my $minimum = 0;
my $keepdiff = 0;
my $delta;
my $length;
my $gap;
my $outdir;
my $manwig = sprintf("%s", which 'manipulate_wig.pl');
my $wig2bw = sprintf("%s", which 'wigToBigWig');
my $bw2bdg = sprintf("%s", which 'bigWigToBedGraph');
my $macs   = sprintf("%s", which 'macs2');
my $bwconvert;
my $database;
my $help;


### Documentation
my $docs = <<DOC;

A script to generate differential enrichment track files. These are 
generated from two provided bedGraph or bigWig tracks. These may be 
fold enrichment (e.g. log2FE) or fragment coverage tracks. This works 
particularly well with nucleosome fragment coverage to identify 
changes in nucleosome density.

Input files are first "zeroed", where any negative scores are reset 
to zero (or values set to a minimum defined value), to avoid examining 
regions with little or no initial enrichment. A differential track is 
then generated by subtracting input2 from input1. Complimentary 
enrichment tracks are then generated from the differential track, 
"positive" being enriched for input1 and "negative" being enriched 
for input2. 

New peaks may be called from these respective enrichment tracks, 
if so desired. If new peaks are to be re-called, specify the minimum 
delta, peak length, and gap length. 

NOTE: Peaks are called on given absolute thresholds and NOT statistical 
confidence. Care should be taken to use a reasonably confident threshold.

VERSION: $VERSION

USAGE: generate_differential.pl -1 <chip1.log2FE.bw> -2 <chip2.log2FE.bw>

OPTIONS:
  Required 
    -1 --in1 <file>         The bw or bdg file for ChIP-1
    -2 --in2 <file>         The bw or bdg file for ChIP-2
  
  Differential
    --min <float>           Set the minimum value to keep in input (0)
    --keepdiff              Keep the differential file
  
  Re-call peaks (optional)
    --delta <float>         Threshold delta score to call a peak
    --len <int>             Minimum length of peak in bp
    --gap <int>             Minimum length of gap in bp
  
  Paths
    --macs <path>           ($macs)
    --manwig <path>         ($manwig)
    --w2bw <path>           ($wig2bw)
    --bw2w <path>           ($bw2bdg)
  
  General
    --outdir <path>         Alternate output directory
    --bw                    Convert output differential files to bw
                               default true if input is bw
                               use --nobw for false
    --db <file>             Indexed database for converting to bw
                               default uses input bigWig
    --help                  Print documentation
DOC


unless (@ARGV) {
	print $docs;
	exit;
}


### Options
GetOptions(
	'1|in1=s'           => \$input1,
	'2|in2=s'           => \$input2,
	'min=f'             => \$minimum,
	'keepdiff!'         => \$keepdiff,
	'delta=f'           => \$delta,
	'len=i'             => \$length,
	'gap=i'             => \$gap,
	'outdir=s'          => \$outdir,
	'macs=s'            => \$macs,
	'manwig=s'          => \$manwig,
	'w2bw=s'            => \$wig2bw,
	'bw2w=s'            => \$bw2bdg,
	'bw!'               => \$bwconvert,
	'db=s'              => \$database,
	'help!'             => \$help,
) or die "unrecognized option!\n";

# check options
if ($help) {
	print $docs;
	exit;
}
die "manipulate_wig.pl not in your PATH!\n" unless $manwig;
die "wigToBigWig not in your PATH!\n" unless $wig2bw;
die "bigWigToBedGraph not in your PATH!\n" unless $bw2bdg;
die "Macs2 not in your PATH!\n" unless $macs;
if (not $input1 and not $input2 and scalar(@ARGV)) {
	# user provided as list
	$input1 = shift @ARGV;
	$input2 = shift @ARGV or die "must provide two input "
}
if ($input1 and not $input2) {
	die "Two input files are required!\n";
}
if ($input1 eq $input2) {
	die "Silly! Both inputs are the same!\n";
}
my $callpeak = 0;
if ($delta and $length and $gap) {
	$callpeak = 1;
}
elsif ($delta or $length or $gap) {
	# at least one but not all three
	die "must specify all three peak parameters: --len, --delta, and --gap!\n";
}


# Initialize ForkManager
my $pm = Parallel::ForkManager->new(2);


### Inputs
my ($base1, $path1, $ext1) = get_path_name($input1);
$base1 =~ s/\.?(?:log2?fe|fragment|rpm)$//;
my ($base2, $path2, $ext2) = get_path_name($input2);
$base2 =~ s/\.?(?:log2?fe|fragment|rpm)$//;

# check bigWig output
if (not defined $bwconvert) {
	if ($ext1 eq '.bw' and $ext2 eq '.bw') {
		$bwconvert = 1;
		print " will convert output files to bigWig\n";
		unless ($database) {
			# recycle bigWig file as a database
			$database = $input1;
		}
	}
}
if ($bwconvert and not $database) {
	if ($ext1 eq '.bw') {
		$database = $input1;
	}
	elsif ($ext2 eq '.bw') {
		$database = $input2;
	}
	else {
		$bwconvert = 0;
		print " no database file defined, will not convert to bigWig\n";
	}
}




### Calculate names
# output path
if ($outdir) {
	unless (-e $outdir) {
		make_path($outdir) or die "unable to make directory $outdir! $!\n";
	}
}
else {
	$outdir = './'; # unix style
}
	
# bedgraph
my $bdg1 = File::Spec->catfile($outdir, $base1 . '.converted.bdg');
my $bdg2 = File::Spec->catfile($outdir, $base2 . '.converted.bdg');
# differential
my $dif1 = File::Spec->catfile($outdir, sprintf("%s_%s.differential.bdg",$base1,$base2));
# enrichment - extension added later
my $enr1 = File::Spec->catfile($outdir, $base1 . '.enrichment');
my $enr2 = File::Spec->catfile($outdir, $base2 . '.enrichment');
# peak
my $peak1 = File::Spec->catfile($outdir, $base1 . '.enriched.narrowPeak');
my $peak2 = File::Spec->catfile($outdir, $base2 . '.enriched.narrowPeak');



 


### Convert
print " Setting minimum values to $minimum in input files\n";
foreach my $i (1..2) {
	$pm->start and next;
	if ($i == 1) {
		# first
		print "   processing $input1 to $bdg1...\n";
		convert_to_minzero_bedgraph($input1, $bdg1, $minimum, 0, undef) or 
			die "something went wrong with conversion!\n";
	}
	else {
		# second
		print "   processing $input2 to $bdg2...\n";
		convert_to_minzero_bedgraph($input2, $bdg2, $minimum, 0, undef) or 
			die "something went wrong with conversion!\n";
	}
	$pm->finish;
}
$pm->wait_all_children;




### Generate differential files
print " Generating differential\n   between $bdg1 and $bdg2...\n";
generate_differential_bedgraph($bdg1, $bdg2, $dif1) or 
	die "something went wrong with conversion!\n";



### Convert
print " Generating respective complimentary enrichment files\n";

foreach my $i (1..2) {
	# if we're not recalling peaks, then we can convert to bigWig here
	
	$pm->start and next;
	if ($i == 1) {
		# first 
		if (not $callpeak and $bwconvert) {
			# convert straight to bigWig here
			print "   converting $enr1 to bigWig...\n";
			convert_to_minzero_bedgraph($dif1, $enr1 . '.bw', 0, 0, $database) or 
				die "something went wrong with conversion!\n";
		}
		else {
			print "   converting $enr1...\n";
			convert_to_minzero_bedgraph($dif1, $enr1 . '.bdg', 0, 0, undef) or 
				die "something went wrong with conversion!\n";
		}
	}
	else {
		# second file
		# we flip the sign in this conversion, negative to positive, positive to zero
		if (not $callpeak and $bwconvert) {
			# convert straight to bigWig here
			print "   converting $enr2 to bigWig...\n";
			convert_to_minzero_bedgraph($dif1, $enr2 . '.bw', 0, 1, $database) or 
				die "something went wrong with conversion!\n";
		}
		else {
			print "   converting $enr2...\n";
			convert_to_minzero_bedgraph($dif1, $enr2 . '.bdg', 0, 1, undef) or 
				die "something went wrong with conversion!\n";
		}
	}
	$pm->finish;
}
$pm->wait_all_children;



### Call peaks
if ($callpeak) {
	print " Calling peaks on enrichment files\n";
	
	foreach my $i (1..2) {
		$pm->start and next;
		if ($i == 1) {
			print "   bdgpeakcall on $enr1...\n";
			call_peaks($enr1 . '.bdg', $peak1) or 
				die "something went wrong with first peak calling!\n";
		}
		else {
			print "   bdgpeakcall on $enr2...\n";
			call_peaks($enr2 . '.bdg', $peak2) or 
				die "something went wrong with second peak calling!\n";
		}
		$pm->finish;
	}
	$pm->wait_all_children;

	# Convert to bigWig
	if ($bwconvert and $database) {
		print " Converting enrichment bedGraph files to bigWig\n";
		foreach my $i (1..2) {
			$pm->start and next;
			if ($i == 1) {
				# first
				my $enr1bw = wig_to_bigwig_conversion(
					wig     => $enr1 . '.bdg',
					db      => $database,
					bwapppath => $wig2bw
				);
				print "   wrote bigWig file $enr1bw\n";
			}
			else {
				# first
				my $enr2bw = wig_to_bigwig_conversion(
					wig     => $enr2 . '.bdg',
					db      => $database,
					bwapppath => $wig2bw
				);
				print "   wrote bigWig file $enr2bw\n";
			}
			$pm->finish;
		}
		$pm->wait_all_children;
	}
}


### Keep differential file
if ($keepdiff and $bwconvert and $database) {
	my $diff1bw = wig_to_bigwig_conversion(
		wig     => $dif1,
		db      => $database,
		bwapppath => $wig2bw
	);
	if ($diff1bw) {
		print "   wrote bigWig file $diff1bw\n";
		unlink $dif1;
	}
}
elsif ($keepdiff and not $bwconvert) {
	print " keeping differential file $dif1\n";
}
else {
	unlink $dif1;
}



### Cleanup
unlink($bdg1, $bdg2);
if ($bwconvert) {
	unlink($enr1 . '.bdg', $enr2 . '.bdg');
}




################ Subroutines


sub get_path_name {
	my $file = shift;
	my ($basename, $path, $extension) = fileparse($file, qr/\.(?:bw|bigwig|bdg|bg|bedgraph)$/);
	unless ($extension) {
		die "$file doesn't have a bedGraph or bigWig extension: bw|bigwig|bdg|bg|bedgraph\n";
	}
	return ($basename, $path, $extension);
}

sub convert_to_minzero_bedgraph {
	my ($infile, $outfile, $min, $flip, $db) = @_;
	
	# generate command
	my $command = sprintf("%s --in %s --min %s --out %s --bw2w %s --w2bw %s", $manwig, 
		$infile, $min, $outfile, $bw2bdg, $wig2bw);
	if ($flip) {
		$command .= " --mult -1";
	}
	if ($db) {
		# add database in case this was added
		$command .= " --db $db";
	}
	my $raw = qx($command);
	if ($raw =~ m/wrote file $outfile/) {
		# completed successfully
		return 1;
	}
	else {
		return 0;
	}
}

sub generate_differential_bedgraph {
	my ($tfile, $cfile, $outfile) = @_;
	
	# generate command
	my $command = sprintf("%s bdgcmp -t %s -c %s -m subtract ", $macs, $tfile, $cfile);
	if ($scale) {
		$command .= "-S $scale ";
	}
	$command .= sprintf("-o %s 2>&1", $outfile);
	my $raw = qx($command);
	if ($raw =~ m/Please check '$outfile'!/) {
		# completed successfully
		return 1;
	}
	else {
		return 0;
	}
}

sub call_peaks {
	my ($infile, $outfile) = @_;
	
	# generate command
	my $command = sprintf("%s bdgpeakcall -i %s -c %s -l %s -g %s -o %s 2>&1", $macs, $infile, 
		$delta, $length, $gap, $outfile);
	my $raw = qx($command);
	if ($raw =~ m/Done/) {
		# completed successfully
		return 1;
	}
	else {
		return 0;
	}
}


